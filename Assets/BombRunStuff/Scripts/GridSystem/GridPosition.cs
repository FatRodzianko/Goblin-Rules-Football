using System;
using System.Collections.Generic;
using UnityEngine;

public struct GridPosition : IEquatable<GridPosition>
{
    private const int MOVE_STRAIGHT_COST = 10;
    private const int MOVE_DIAGONAL_COST = 14;

    public int x;
    public int y;

    public GridPosition(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
    // autogenerated by visual studio...
    public override bool Equals(object obj)
    {
        return obj is GridPosition position &&
               x == position.x &&
               y == position.y;
    }
    // autogenerate by visual studio...
    public bool Equals(GridPosition other)
    {
        return this == other;
    }

    // autogenerated by visual studio...
    public override int GetHashCode()
    {
        return HashCode.Combine(x, y);
    }

    public override string ToString()
    {
        return "x: " + x + "; y: " + y + ";";
    }
    public static bool operator ==(GridPosition a, GridPosition b)
    {
        return a.x == b.x && a.y == b.y;
    }
    public static bool operator !=(GridPosition a, GridPosition b)
    {
        return !(a == b);
    }
    public static GridPosition operator +(GridPosition a, GridPosition b)
    {
        return new GridPosition(a.x + b.x, a.y + b.y);
    }
    public static GridPosition operator -(GridPosition a, GridPosition b)
    {
        return new GridPosition(a.x - b.x, a.y - b.y);
    }
    public static int Distance(GridPosition a, GridPosition b)
    {
        int distX = Mathf.Abs(a.x - b.x);
        int distY = Mathf.Abs(a.y - b.y);
        int orthogonal = Mathf.Min(distX, distY);
        int diagonal = Mathf.Max(distX, distY) - orthogonal;
        return orthogonal * MOVE_STRAIGHT_COST + diagonal * MOVE_DIAGONAL_COST;
    }
    public static int CalculateDistance(GridPosition a, GridPosition b)
    {
        GridPosition gridPositionDistance = a - b;
        int distance = Mathf.Abs(gridPositionDistance.x) + Mathf.Abs(gridPositionDistance.y);

        // Get the "x distance" and "z distance." Basically how far do you need to move in the X axis and how far do you move in the Z axis to get from point a to b
        int xDistance = Mathf.Abs(gridPositionDistance.x);
        int yDistance = Mathf.Abs(gridPositionDistance.y);

        // get the distance that will be traveled diagonally by getting the "overlap" between the x and z distances.
        // Ex.: If you move to a position that is 1 distance on the x and 2 on the z, then you'd go diagonally 1 time, then straight 1 additional time
        // Ex.: if you moved 2 on x, and 5 on z, 
        int diagonalDistance = Mathf.Min(xDistance, yDistance);

        // Get the remaining "Straight" distance by subtracting the x distance from z distance
        int remainingStraightDistance = Mathf.Abs(xDistance - yDistance);

        return (diagonalDistance * MOVE_DIAGONAL_COST) + (remainingStraightDistance * MOVE_STRAIGHT_COST);
    }
    public static List<GridPosition> GetNeighborGridPositions(GridPosition startingGridPosition, int distanceFromStartingPosition, bool makeCircular = false)
    {
        List<GridPosition> neighborGridPositions = new List<GridPosition>();

        for (int x = -distanceFromStartingPosition; x <= distanceFromStartingPosition; x++)
        {
            for (int y = -distanceFromStartingPosition; y <= distanceFromStartingPosition; y++)
            {
                GridPosition offsetGridPosition = new GridPosition(x, y);
                GridPosition newNeighborPosition = startingGridPosition + offsetGridPosition;

                // only needed for square grid. Hex grid won't need this?
                if (makeCircular)
                {
                    int testDistance = Mathf.Abs(x) + Mathf.Abs(y);
                    if (testDistance > distanceFromStartingPosition)
                    {
                        continue;
                    }
                }                

                neighborGridPositions.Add(newNeighborPosition);
            }
        }
        return neighborGridPositions;
    }
}